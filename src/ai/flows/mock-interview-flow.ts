
'use server';

/**
 * @fileOverview Simulates a mock interview with an AI interviewer.
 * This flow generates the first question for a mock interview.
 * Implements a cascading API key fallback: User Gemini -> User OpenAI -> User Claude -> Platform Default.
 *
 * - getFirstInterviewQuestion - A function that generates the first interview question.
 * - InterviewConfigInput - The input type for generating the question (resume, job description, optional API keys).
 * - FirstQuestionOutput - The return type, containing the first question.
 */

import { genkit as baseGenkit } from 'genkit';
import { googleAI } from '@genkit-ai/googleai';
import { openai } from '@genkit-ai/openai'; // Ensure @genkit-ai/openai is installed if used
import { anthropic } from '@genkit-ai/anthropic'; // Ensure @genkit-ai/anthropic is installed if used
import { ai } from '@/ai/genkit'; // Global AI instance
import { z } from 'genkit';

const InterviewConfigInputSchema = z.object({
  resume: z
    .string()
    .describe('The resume of the candidate, as a data URI that must include a MIME type and use Base64 encoding. Expected format: \'data:<mimetype>;base64,<encoded_data>\'.'),
  jobDescription: z.string().describe('The job description for the role the candidate is interviewing for.'),
  geminiApiKey: z.string().optional().describe('Optional Google Gemini API key to use for this request.'),
  openaiApiKey: z.string().optional().describe('Optional OpenAI API key to use for this request.'),
  claudeApiKey: z.string().optional().describe('Optional Anthropic Claude API key to use for this request.'),
});
export type InterviewConfigInput = z.infer<typeof InterviewConfigInputSchema>;

const FirstQuestionOutputSchema = z.object({
  firstQuestion: z.string().describe("The first interview question generated by the AI interviewer based on the candidate's resume and the job description, including a brief opening greeting."),
});
export type FirstQuestionOutput = z.infer<typeof FirstQuestionOutputSchema>;

const FIRST_QUESTION_PROMPT_CONFIG_BASE = {
  name: 'firstQuestionPrompt',
  input: { schema: InterviewConfigInputSchema }, // This is for the flow, prompt will take subset
  output: { schema: FirstQuestionOutputSchema },
  prompt: `You are an AI Interviewer.
Based on the candidate's resume and the provided job description, your task is to:
1. Start with a brief, professional opening greeting (e.g., "Hello! I'm your AI interviewer for today. Let's begin with your first question.").
2. Generate the *first* relevant interview question to start the mock interview.

Job Description:
{{{jobDescription}}}

Candidate's Resume:
{{media url=resume}}

Please provide the greeting followed by the first question as a single string.
`,
};

const firstQuestionGlobalPlatformPrompt = ai.definePrompt(FIRST_QUESTION_PROMPT_CONFIG_BASE);

async function generateFirstQuestionLogic(input: InterviewConfigInput): Promise<FirstQuestionOutput> {
  let llmResponse: FirstQuestionOutput | undefined;

  const promptInput = { resume: input.resume, jobDescription: input.jobDescription };

  const attempts = [
    {
      providerName: 'Gemini',
      apiKey: input.geminiApiKey,
      plugin: googleAI,
      modelName: 'googleai/gemini-2.0-flash',
    },
    {
      providerName: 'OpenAI',
      apiKey: input.openaiApiKey,
      plugin: openai,
      modelName: 'openai/gpt-4o-mini',
    },
    {
      providerName: 'Claude',
      apiKey: input.claudeApiKey,
      plugin: anthropic,
      modelName: 'anthropic/claude-3-haiku-20240307',
    },
  ];

  for (const attempt of attempts) {
    if (attempt.apiKey && attempt.plugin) {
      console.log(`Attempting to use user-provided ${attempt.providerName} API key for first interview question.`);
      try {
        const tempAi = baseGenkit({
          plugins: [attempt.plugin({ apiKey: attempt.apiKey })],
        });
        const tempPrompt = tempAi.definePrompt({
          ...FIRST_QUESTION_PROMPT_CONFIG_BASE,
          input: { schema: z.object({ resume: z.string(), jobDescription: z.string() }) }, // Refine for actual prompt
          name: `${FIRST_QUESTION_PROMPT_CONFIG_BASE.name}_user${attempt.providerName}_${Date.now()}`,
          config: { model: attempt.modelName },
        });

        const { output } = await tempPrompt(promptInput);
        llmResponse = output;
        if (!llmResponse) throw new Error(`Model (${attempt.providerName}) returned no output.`);

        console.log(`Successfully used user-provided ${attempt.providerName} API key for first question.`);
        return llmResponse;
      } catch (e: any) {
        console.warn(`Error using user-provided ${attempt.providerName} API key for first question:`, e.message);
        const errorMessage = (e.message || "").toLowerCase();
        const errorStatus = e.status || e.code;
        const errorType = (e.type || "").toLowerCase();
        const isKeyError =
          errorMessage.includes("api key") ||
          errorMessage.includes("permission denied") ||
          errorMessage.includes("quota exceeded") ||
          errorMessage.includes("authentication failed") ||
          errorMessage.includes("invalid_request") ||
          errorMessage.includes("billing") ||
          errorMessage.includes("insufficient_quota") ||
          errorType.includes("api_key") ||
          errorStatus === 401 || errorStatus === 403 || errorStatus === 429 ||
          (e.cause && typeof e.cause === 'object' && 'code' in e.cause && e.cause.code === 7) ||
          (e.response && e.response.data && e.response.data.error && /api key/i.test(e.response.data.error.message));
        
        if (!isKeyError) throw e;
        console.log(`User's ${attempt.providerName} API key failed. Attempting next fallback.`);
      }
    }
  }

  console.log("Falling back to platform's default API key for first interview question.");
  const { output } = await firstQuestionGlobalPlatformPrompt(promptInput);
  llmResponse = output;

  if (!llmResponse) {
    throw new Error("AI model did not return the expected output for the first question after all attempts.");
  }
  return llmResponse;
}

const firstQuestionFlow = ai.defineFlow(
  {
    name: 'firstQuestionFlow',
    inputSchema: InterviewConfigInputSchema,
    outputSchema: FirstQuestionOutputSchema,
  },
  generateFirstQuestionLogic
);

export async function getFirstInterviewQuestion(input: InterviewConfigInput): Promise<FirstQuestionOutput> {
  return firstQuestionFlow(input);
}
